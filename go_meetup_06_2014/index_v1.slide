Channels in Go
Subtitle of document
15:04 2 Jan 2006

Author Name
Job title, Company
joe@example.com
http://url/
@twitter_name

* Hello function

.code simple_hello.go /^func hello/,/^}/
.play simple_hello.go /^func main/,/^}/

* Hello function with a goroutine.

.code hello_without_sleep.go /^func hello/,/^}/
.play hello_without_sleep.go /^func main/,/^}/

* Hello function with a goroutine.

.code hello_world_without_channels.go /^func hello/,/^}/
.play hello_world_without_channels.go /^func main/,/^}/

* Channels
A channel in Go provides a connection between two goroutines, allowing them to communicate.

.code syntax_overview.go /^\/\/.*Create/,/bool/
.code syntax_overview.go /^\/\/.*Send/,/true$/
.code syntax_overview.go /^\/\/ Receive/,/ch$/

* Hello function with a channel
.code hello_world_channels.go /^func hello/,/^}/
.play hello_world_channels.go /^func main/,/^}/

* Synchronization
Sends and receives block until the other side is ready.

<-c, it waits for a value to be sent.

c <- "Hello", it waits for a receiver to be ready.

Allows goroutines to synchronize without explicit locks or condition variables.

It's safe to share channels across routines.

* Synchronization

Channels can be used for communication and synchronization.

* Buffered Channels

.code buffered_channels_syntax_overview.go /^\/\/.*Create/,/100\)$/

* Buffered Channels

.play buffered_channels.go /^func main/,/^}/

* Buffered Channels

Buffered channels don't synchronize.

* The Go approach

Don't communicate by sharing memory, share memory by communicating.

* Generator: function that returns a channel

.code generator.go /^func hello/,/^}/
.play generator.go /^func main/,/^}/

* Generator: function that returns a channel

.play joe_ann.go /^func main/,/^}/

* fan-in function

.code fan_in.go /^func fanIn/,/^}/
.play fan_in.go /^func main/,/^}/

* Select

.code select.go

* Select
The select statement lets a goroutine wait on multiple communication operations.

A select blocks until one of its cases can run, then it executes that case. It chooses one at random if multiple are ready.

You can't depend on the order.

* Timeout using select

.play select_timeout.go /^func main/,/^}/

* Real world example

sequential
concurrent
concurrent + timeout
replicas

* the last
Go Concurrency Patterns - http://www.youtube.com/watch?v=f6kdp27TYZs
http://tour.golang.org/
